{
  "name": "TypeScript",
  "description": "TypeScript programming questions",
  "questions": [
    {
      "id": 1,
      "question": "What is TypeScript and what problems does it solve?",
      "answer": "TypeScript is a superset of JavaScript that adds static typing. Benefits: 1) Catches errors at compile-time, 2) Better IDE support (autocomplete, refactoring), 3) Improved code documentation, 4) Easier refactoring in large codebases, 5) Enhanced OOP features (interfaces, generics).",
      "options": [
        "A JavaScript framework for building UIs",
        "A superset of JavaScript with static typing",
        "A database query language"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": ["basics"]
    },
    {
      "id": 2,
      "question": "Explain the difference between 'interface' and 'type' in TypeScript.",
      "answer": "Both define types, but: INTERFACE - Can be extended/merged, better for object shapes, more readable errors. TYPE - Can represent unions, intersections, primitives, tuples. Use interface for objects/classes, type for unions/complex types. Example: type ID = string | number; interface User { id: ID; name: string; }",
      "options": [
        "They are exactly the same",
        "Interface can be merged, type supports unions",
        "Type is faster at runtime"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["types", "interfaces"]
    },
    {
      "id": 3,
      "question": "What are TypeScript Generics and why are they useful?",
      "answer": "Generics allow writing reusable code that works with multiple types. Example: function identity<T>(arg: T): T { return arg; } Benefits: 1) Type safety without duplication, 2) Code reusability, 3) Better than 'any' type. Common in arrays: Array<T>, Promise<T>.",
      "options": [
        "Functions that only work with generic objects",
        "Reusable code with type safety for multiple types",
        "A way to skip type checking"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["generics", "advanced"]
    },
    {
      "id": 4,
      "question": "What is 'unknown' type and how is it different from 'any'?",
      "answer": "'unknown' is type-safe version of 'any'. With 'any', you can do anything (no checks). With 'unknown', you must narrow the type before use (type guards). Example: let val: unknown; if (typeof val === 'string') { val.toUpperCase(); } Use 'unknown' instead of 'any' for better safety.",
      "options": [
        "They are the same type",
        "'unknown' requires type checking before use, 'any' doesn't",
        "'unknown' is only for external APIs"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["types", "safety"]
    },
    {
      "id": 5,
      "question": "What are TypeScript utility types? Give examples.",
      "answer": "Utility types transform existing types. Common ones: 1) Partial<T> - makes all properties optional, 2) Required<T> - makes all required, 3) Pick<T, K> - selects specific properties, 4) Omit<T, K> - excludes properties, 5) Record<K, T> - creates object type. Example: Partial<User> allows all User fields to be optional.",
      "options": [
        "Built-in types that transform other types",
        "Helper functions for debugging",
        "Types only for utility libraries"
      ],
      "correctOption": 0,
      "difficulty": "medium",
      "tags": ["utility-types", "advanced"]
    },
    {
      "id": 6,
      "question": "Explain TypeScript's 'never' type and when to use it.",
      "answer": "'never' represents values that never occur. Uses: 1) Functions that never return (throw errors, infinite loops), 2) Exhaustive type checking, 3) Unreachable code. Example: function error(msg: string): never { throw new Error(msg); } Also used in conditional types to filter out unwanted cases.",
      "options": [
        "For values that are always null",
        "For values that never occur (unreachable code)",
        "For optional function parameters"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["types", "advanced"]
    },
    {
      "id": 7,
      "question": "What is type narrowing in TypeScript?",
      "answer": "Type narrowing is refining types to more specific ones using type guards. Methods: 1) typeof checks, 2) instanceof, 3) in operator, 4) Custom type guards with 'is'. Example: if (typeof x === 'string') { x.toUpperCase(); } TypeScript knows x is string inside the block.",
      "options": [
        "Removing unused types from your code",
        "Refining types to more specific ones with type guards",
        "Reducing the size of compiled JavaScript"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["type-guards", "narrowing"]
    },
    {
      "id": 8,
      "question": "What are mapped types in TypeScript?",
      "answer": "Mapped types create new types by transforming properties of existing types. Syntax: { [K in keyof T]: NewType }. Example: type Readonly<T> = { readonly [K in keyof T]: T[K]; }. Useful for creating variations like making all properties optional, readonly, or nullable.",
      "options": [
        "Types for geographic mapping",
        "New types by transforming existing type properties",
        "Types that map to database schemas"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["mapped-types", "advanced"]
    },
    {
      "id": 9,
      "question": "Explain the 'readonly' modifier in TypeScript.",
      "answer": "readonly makes properties immutable after initialization. Can be used on: 1) Interface/type properties, 2) Array (ReadonlyArray<T>), 3) Class properties. Example: interface Point { readonly x: number; } Once set, x cannot be changed. Use for immutability and preventing accidental modifications.",
      "options": [
        "Makes properties private",
        "Makes properties immutable after initialization",
        "Only allows read operations on files"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": ["modifiers", "immutability"]
    },
    {
      "id": 10,
      "question": "What is the difference between 'const' and 'readonly'?",
      "answer": "'const' - for variables, prevents reassignment. 'readonly' - for properties, prevents modification after initialization. const x = [1,2]; x.push(3); // OK. interface Props { readonly items: number[]; } props.items.push(3); // Error. Use const for variables, readonly for object properties.",
      "options": [
        "They are the same thing",
        "'const' for variables, 'readonly' for properties",
        "'const' is for constants, 'readonly' for strings"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["const", "readonly", "immutability"]
    },
    {
      "id": 11,
      "question": "What are conditional types in TypeScript?",
      "answer": "Conditional types select types based on conditions. Syntax: T extends U ? X : Y. Example: type IsString<T> = T extends string ? true : false. Useful for: 1) Type filtering, 2) Building complex utility types, 3) Creating type-safe APIs. Built-in examples: Exclude, Extract, NonNullable.",
      "options": [
        "Types that depend on runtime conditions",
        "Types that select based on type conditions (T extends U ? X : Y)",
        "Types for if-else statements only"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["conditional-types", "advanced"]
    },
    {
      "id": 12,
      "question": "Explain the 'keyof' operator in TypeScript.",
      "answer": "'keyof' creates a union of all property names (keys) of a type. Example: interface User { name: string; age: number; } type UserKeys = keyof User; // 'name' | 'age'. Used for: 1) Type-safe property access, 2) Mapped types, 3) Index signatures. Often combined with generics.",
      "options": [
        "Gets the values of an object",
        "Creates a union of all property names of a type",
        "Checks if a key exists in an object"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["keyof", "utility-operators"]
    },
    {
      "id": 13,
      "question": "What is the purpose of 'declare' keyword in TypeScript?",
      "answer": "'declare' tells TypeScript a variable/function exists elsewhere (no implementation). Uses: 1) Ambient declarations (.d.ts files), 2) Declaring global variables, 3) Third-party library types. Example: declare const API_URL: string; Used for type checking without runtime code.",
      "options": [
        "Declares a new variable",
        "Tells TypeScript something exists elsewhere (ambient declarations)",
        "Makes variables public"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["declare", "ambient"]
    },
    {
      "id": 14,
      "question": "What are TypeScript decorators and when would you use them?",
      "answer": "Decorators are special functions that modify classes, methods, properties, or parameters at design time. Uses: 1) Metadata (Angular, NestJS), 2) Validation, 3) Logging, 4) Dependency injection. Example: @Component, @Injectable. Syntax: @decorator class MyClass {}. Note: Still experimental, enable with experimentalDecorators.",
      "options": [
        "Functions that add styling to components",
        "Special functions that modify classes/methods at design time",
        "A way to comment your code"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["decorators", "metadata", "experimental"]
    },
    {
      "id": 15,
      "question": "What is 'strictNullChecks' in TypeScript?",
      "answer": "'strictNullChecks' is a compiler option that prevents null/undefined from being assigned to non-nullable types. When enabled: 1) Must explicitly allow null (string | null), 2) Prevents 'Cannot read property of undefined' errors, 3) Safer code. Example: let x: string; x = null; // Error with strictNullChecks.",
      "options": [
        "A runtime check for null values",
        "Compiler option preventing null/undefined in non-nullable types",
        "A function that removes null from arrays"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["compiler-options", "null-safety"]
    },
    {
      "id": 16,
      "question": "Explain type assertion in TypeScript and its syntax.",
      "answer": "Type assertion tells TypeScript to treat a value as a specific type (like type casting). Two syntaxes: 1) angle-bracket: <Type>value, 2) as: value as Type. Example: let len = (input as string).length; Use when you know more than TypeScript. Note: Doesn't perform runtime conversion, just compile-time.",
      "options": [
        "A way to convert types at runtime",
        "Telling TypeScript to treat a value as a specific type",
        "Testing if a variable is a certain type"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": ["type-assertion", "casting"]
    },
    {
      "id": 17,
      "question": "What is the 'infer' keyword in TypeScript?",
      "answer": "'infer' is used within conditional types to extract/infer types. Example: type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never; Extracts return type of function. Uses: 1) Type extraction, 2) Building advanced utility types, 3) Pattern matching on types.",
      "options": [
        "Makes TypeScript guess types automatically",
        "Extracts/infers types within conditional types",
        "A debugging keyword"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["infer", "conditional-types", "advanced"]
    },
    {
      "id": 18,
      "question": "What are index signatures in TypeScript?",
      "answer": "Index signatures define types for dynamic property names. Syntax: { [key: string]: Type }. Example: interface StringMap { [key: string]: string; } Allows: obj['anyKey']. Uses: 1) Dictionaries, 2) Dynamic objects, 3) Flexible APIs. Can use string, number, or symbol as index type.",
      "options": [
        "Ways to index arrays",
        "Types for dynamic property names { [key: string]: Type }",
        "Performance optimization for lookups"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["index-signatures", "dynamic-types"]
    },
    {
      "id": 19,
      "question": "What is the difference between 'enum' and 'const enum' in TypeScript?",
      "answer": "enum - generates JavaScript object code. const enum - fully erased at runtime, replaced with literal values (more efficient). Example: const enum Status { Active = 1 }. let s = Status.Active; // compiles to: let s = 1. Use const enum for performance, regular enum when you need runtime object.",
      "options": [
        "No difference, they're aliases",
        "'const enum' is erased at runtime, regular enum generates JS code",
        "'const enum' can only have constant values"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": ["enum", "const-enum", "performance"]
    },
    {
      "id": 20,
      "question": "What are template literal types in TypeScript?",
      "answer": "Template literal types create new string literal types by combining existing ones. Syntax: type Greeting = `Hello ${Name}`; Example: type HttpMethod = 'GET' | 'POST'; type Endpoint = `/api/${HttpMethod}`; Uses: 1) Type-safe strings, 2) Building URL types, 3) Event names. TypeScript 4.1+ feature.",
      "options": [
        "String templates for HTML",
        "New string literal types by combining existing ones",
        "Functions that return template strings"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": ["template-literals", "string-types", "advanced"]
    }
  ]
}

