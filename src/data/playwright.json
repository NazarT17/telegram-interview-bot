{
  "name": "Playwright",
  "description": "Playwright testing framework questions",
  "questions": [
    {
      "id": 1,
      "question": "What is Playwright and what makes it different from Selenium?",
      "answer": "Playwright is a modern end-to-end testing framework by Microsoft. Key differences: 1) Auto-wait mechanism (waits for elements automatically), 2) Supports multiple browsers with single API, 3) Better handling of modern web apps (SPAs), 4) Built-in network interception, 5) Faster execution with parallel testing.",
      "options": [
        "A playwright management software",
        "Modern E2E framework with auto-wait and multi-browser support",
        "A Selenium wrapper library"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": [
        "basics",
        "comparison"
      ]
    },
    {
      "id": 2,
      "question": "Explain the difference between page.click() and page.locator().click() in Playwright.",
      "answer": "page.click(selector) is the legacy method that immediately searches for element. page.locator(selector).click() is the modern approach using locators - it's lazy (doesn't search until action), has auto-waiting, better error messages, and is more reliable for dynamic content.",
      "options": [
        "They are exactly the same",
        "Locator is lazy and has auto-waiting",
        "page.click() is faster"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "locators",
        "best-practices"
      ]
    },
    {
      "id": 3,
      "question": "How do you handle file uploads in Playwright?",
      "answer": "Use page.setInputFiles(selector, filePath) or locator.setInputFiles(). For multiple files: pass an array. To remove files: pass empty array. Example: await page.locator('input[type=\"file\"]').setInputFiles('path/to/file.pdf');",
      "options": [
        "Using page.upload() method",
        "Using setInputFiles() method",
        "Playwright doesn't support file uploads"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "file-handling",
        "interactions"
      ]
    },
    {
      "id": 4,
      "question": "What are Playwright fixtures and why are they useful?",
      "answer": "Fixtures are a way to establish test environment and share setup/teardown logic. They provide: 1) Automatic setup/cleanup, 2) Dependency injection, 3) Composability, 4) Isolation between tests. Example: custom 'authenticatedPage' fixture that logs in before each test.",
      "options": [
        "Fixed data for testing",
        "Setup/teardown logic with dependency injection",
        "Built-in test assertions"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": [
        "fixtures",
        "test-organization"
      ]
    },
    {
      "id": 5,
      "question": "How do you handle multiple browser contexts in Playwright?",
      "answer": "Browser contexts are isolated environments (like incognito). Create with browser.newContext(). Uses: 1) Multi-user scenarios, 2) Different permissions/locales, 3) Test isolation. Example: const context1 = await browser.newContext(); const page1 = await context1.newPage(); Each context has separate cookies/storage.",
      "options": [
        "Using browser.newContext() for isolated environments",
        "Opening multiple browser windows",
        "Contexts are not supported"
      ],
      "correctOption": 0,
      "difficulty": "medium",
      "tags": [
        "contexts",
        "isolation"
      ]
    },
    {
      "id": 6,
      "question": "What is the purpose of test.describe.configure() in Playwright?",
      "answer": "test.describe.configure() sets options for a test suite. Common configs: 1) mode: 'parallel' or 'serial', 2) retries, 3) timeout. Example: test.describe.configure({ mode: 'serial' }); makes tests run sequentially. Use for tests that can't run in parallel (share state, database).",
      "options": [
        "To describe what tests do",
        "To configure test suite options (parallel/serial mode)",
        "To add test descriptions"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "configuration",
        "test-organization"
      ]
    },
    {
      "id": 7,
      "question": "How do you intercept and mock network requests in Playwright?",
      "answer": "Use page.route() to intercept. Methods: 1) route.fulfill() - mock response, 2) route.continue() - modify and continue, 3) route.abort() - block request. Example: await page.route('**/api/users', route => route.fulfill({ json: mockData })); Useful for testing edge cases, offline mode.",
      "options": [
        "Using page.mock() method",
        "Using page.route() with fulfill/continue/abort",
        "Network mocking is not supported"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": [
        "mocking",
        "network"
      ]
    },
    {
      "id": 8,
      "question": "Explain Playwright's auto-waiting mechanism.",
      "answer": "Playwright automatically waits for elements to be actionable before performing actions. Checks: 1) Attached to DOM, 2) Visible, 3) Stable (not animating), 4) Receives events, 5) Enabled. Default timeout: 30s. Reduces flaky tests from manual waits. Can customize with { timeout } option.",
      "options": [
        "Waits for page load only",
        "Waits for elements to be actionable (visible, stable, enabled)",
        "You must manually wait for everything"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": [
        "auto-wait",
        "stability"
      ]
    },
    {
      "id": 9,
      "question": "What are the benefits of using Playwright's codegen tool?",
      "answer": "Codegen (playwright codegen) records browser interactions and generates test code. Benefits: 1) Quick test creation, 2) Learns selectors, 3) Generates in multiple languages, 4) Shows Playwright Inspector. Great for: beginners, quick prototypes, finding selectors. Still need to refactor generated code for maintainability.",
      "options": [
        "Generates code from documentation",
        "Records interactions and generates test code",
        "Only generates TypeScript types"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": [
        "codegen",
        "tools"
      ]
    },
    {
      "id": 10,
      "question": "How do you handle authentication in Playwright tests efficiently?",
      "answer": "Best practice: Authenticate once, reuse session. Methods: 1) Save storage state: await context.storageState({ path: 'auth.json' }), 2) Reuse: await browser.newContext({ storageState: 'auth.json' }). Avoid logging in for every test. Can also use API calls for auth. Saves time and reduces flakiness.",
      "options": [
        "Login before every test",
        "Save and reuse storage state",
        "Use cookies only"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": [
        "authentication",
        "performance"
      ]
    },
    {
      "id": 11,
      "question": "What is the purpose of page.waitForLoadState() in Playwright?",
      "answer": "page.waitForLoadState() waits for specific load state. States: 1) 'load' - full page load, 2) 'domcontentloaded' - DOM ready, 3) 'networkidle' - no network activity for 500ms. Example: await page.waitForLoadState('networkidle'); Useful after navigation or waiting for AJAX requests. Auto-wait usually handles this.",
      "options": [
        "Waits for page to fully load",
        "Waits for specific load states (load/domcontentloaded/networkidle)",
        "Waits for loading animations"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "waiting",
        "page-lifecycle"
      ]
    },
    {
      "id": 12,
      "question": "How do you run tests in different browsers with Playwright?",
      "answer": "Configure in playwright.config.ts with projects array. Example: projects: [{ name: 'chromium', use: { ...devices['Desktop Chrome'] }}, { name: 'webkit' }]. Run with: npx playwright test --project=webkit. Supports: Chromium, Firefox, WebKit (Safari). Can also configure mobile devices, viewports.",
      "options": [
        "Install separate test frameworks",
        "Configure projects in playwright.config.ts",
        "Change browser in each test file"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "configuration",
        "cross-browser"
      ]
    },
    {
      "id": 13,
      "question": "What are Playwright's built-in assertions and how do they differ from expect()?",
      "answer": "Playwright has web-first assertions: expect(locator).toBeVisible(), toHaveText(), toBeEnabled(), etc. They auto-wait and retry until timeout. Different from basic expect(): 1) Auto-retry, 2) Better error messages, 3) Handle async automatically. Example: await expect(page.locator('h1')).toHaveText('Welcome');",
      "options": [
        "No difference from regular expect()",
        "Web-first assertions with auto-retry and auto-wait",
        "Only for DOM assertions"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "assertions",
        "testing"
      ]
    },
    {
      "id": 14,
      "question": "How do you handle iframes in Playwright?",
      "answer": "Use page.frameLocator() for modern approach. Example: await page.frameLocator('iframe#myframe').locator('button').click(); Or legacy: const frame = page.frame({ name: 'frameName' }). frameLocator is recommended - works with auto-waiting, better for nested iframes, more reliable.",
      "options": [
        "Switch to iframe context like Selenium",
        "Use page.frameLocator() for modern approach",
        "Iframes are not supported"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": [
        "iframes",
        "locators"
      ]
    },
    {
      "id": 15,
      "question": "What is Playwright's trace viewer and when should you use it?",
      "answer": "Trace viewer is a debugging tool that records test execution. Shows: screenshots, DOM snapshots, network, console, actions timeline. Enable with: await context.tracing.start(). View: npx playwright show-trace trace.zip. Use for: debugging failures, CI investigations, understanding test behavior. Powerful for post-mortem analysis.",
      "options": [
        "A code coverage tool",
        "Debugging tool showing test execution timeline and snapshots",
        "A performance profiler"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "debugging",
        "tracing"
      ]
    },
    {
      "id": 16,
      "question": "How do you handle downloads in Playwright?",
      "answer": "Listen for download event: const download = await page.waitForEvent('download'); await button.click(); Save: await download.saveAs('path/to/save'); Get info: download.suggestedFilename(). Can also use download.path() for temp location. Playwright handles download automatically without browser prompts.",
      "options": [
        "Configure browser download settings",
        "Use waitForEvent('download') and saveAs()",
        "Downloads are not supported"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "downloads",
        "file-handling"
      ]
    },
    {
      "id": 17,
      "question": "What is the purpose of test.use() in Playwright?",
      "answer": "test.use() shares configuration or fixtures within a test file. Example: test.use({ viewport: { width: 1280, height: 720 }}); Applies to all tests in scope. Can also use for custom fixtures. Alternative to repeating config in every test. Scoped to describe block if used within one.",
      "options": [
        "Imports test utilities",
        "Shares configuration/fixtures within test scope",
        "Declares test dependencies"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": [
        "configuration",
        "fixtures"
      ]
    },
    {
      "id": 18,
      "question": "How do you test geolocation and permissions in Playwright?",
      "answer": "Set in context options: await browser.newContext({ geolocation: { latitude: 51.5074, longitude: -0.1278 }, permissions: ['geolocation'] }). Can also use context.setGeolocation() and context.grantPermissions(). Useful for testing location-based features, camera access, notifications, etc.",
      "options": [
        "Not possible in Playwright",
        "Set geolocation and permissions in context options",
        "Only works with Chrome"
      ],
      "correctOption": 1,
      "difficulty": "hard",
      "tags": [
        "geolocation",
        "permissions"
      ]
    },
    {
      "id": 19,
      "question": "What are Playwright's locator strategies and which is most recommended?",
      "answer": "Strategies: 1) Role-based (recommended): getByRole(), 2) Text: getByText(), 3) Label: getByLabel(), 4) Placeholder: getByPlaceholder(), 5) Test ID: getByTestId(), 6) CSS/XPath. Recommendation: Use role-based for accessibility, test IDs for dynamic content. Avoid CSS/XPath unless necessary - brittle.",
      "options": [
        "Only CSS and XPath",
        "Role-based, text, label, test ID (role-based recommended)",
        "ID and class name only"
      ],
      "correctOption": 1,
      "difficulty": "easy",
      "tags": [
        "locators",
        "best-practices"
      ]
    },
    {
      "id": 20,
      "question": "How do you handle popup windows and new tabs in Playwright?",
      "answer": "Listen for popup event: const [popup] = await Promise.all([page.waitForEvent('popup'), page.click('a[target=\"_blank\"]')]); Then interact: await popup.locator('h1').textContent(). Playwright tracks all pages, no need to switch contexts. Can also use page.context().pages() to get all pages.",
      "options": [
        "Switch window handles like Selenium",
        "Use waitForEvent('popup') and get new page reference",
        "Popups are blocked in Playwright"
      ],
      "correctOption": 1,
      "difficulty": "medium",
      "tags": [
        "popups",
        "multi-page"
      ]
    }
  ]
}
